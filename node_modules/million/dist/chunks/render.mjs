import { F as Flags, r as resolveVNode, X as X_CHAR, C as COLON_CHAR, d as XML_NS, f as XLINK_NS, O as OLD_VNODE_FIELD, D as DeltaTypes, E as EffectTypes, N as NODE_OBJECT_POOL_FIELD, g as DOM_REF_FIELD } from './h.mjs';
import { f as fromDomNodeToVNode } from './convert.mjs';

const createElement = (vnode, attachField = true) => {
  if (vnode === void 0 || vnode === null)
    return document.createComment("");
  if (typeof vnode === "string")
    return document.createTextNode(vnode);
  if (typeof vnode === "object" && vnode?.flag === Flags.ENTITY) {
    if (vnode.el)
      return vnode.el;
    else
      return createElement(resolveVNode(vnode));
  }
  const el = vnode.props?.ns ? document.createElementNS(vnode.props?.ns, vnode.tag) : document.createElement(vnode.tag);
  if (vnode.props) {
    for (const propName in vnode.props) {
      const propValue = vnode.props[propName];
      if (propName.startsWith("on")) {
        const eventPropName = propName.slice(2).toLowerCase();
        el.addEventListener(eventPropName, propValue);
      } else if (propName.charCodeAt(0) === X_CHAR) {
        if (propName.charCodeAt(3) === COLON_CHAR) {
          el.setAttributeNS(XML_NS, propName, String(propValue));
        } else if (propName.charCodeAt(5) === COLON_CHAR) {
          el.setAttributeNS(XLINK_NS, propName, String(propValue));
        }
      } else if (el[propName] !== void 0 && !(el instanceof SVGElement)) {
        el[propName] = propValue;
      } else {
        el.setAttribute(propName, String(propValue));
      }
    }
  }
  if (vnode.children) {
    if (vnode.flag === Flags.ELEMENT_TEXT_CHILDREN) {
      el.textContent = Array.isArray(vnode.children) ? vnode.children?.join("") : vnode.children;
    } else {
      for (let i = 0; i < vnode.children.length; ++i) {
        el.appendChild(createElement(vnode.children[i], false));
      }
    }
  }
  if (attachField)
    el[OLD_VNODE_FIELD] = vnode;
  return el;
};

const useChildren = (drivers = []) => (el, newVNode, oldVNode, commit = (work) => work(), effects = [], driver) => {
  const getData = (element) => ({
    el: element,
    newVNode,
    oldVNode,
    effects,
    commit,
    driver
  });
  const finish = (element) => {
    const data = getData(element);
    for (let i = 0; i < drivers.length; ++i) {
      commit(() => {
        drivers[i](el, newVNode, oldVNode, commit, effects, driver);
      }, data);
    }
    return data;
  };
  const oldVNodeChildren = oldVNode?.children ?? [];
  const newVNodeChildren = newVNode.children;
  const delta = newVNode.delta;
  const diff = (el2, newVNode2, oldVNode2) => driver(el2, newVNode2, oldVNode2, commit, effects).effects;
  if (delta) {
    for (let i = 0; i < delta.length; ++i) {
      const [deltaType, deltaPosition] = delta[i];
      const child = el.childNodes.item(deltaPosition);
      if (deltaType === DeltaTypes.CREATE) {
        effects.push({
          el,
          type: EffectTypes.CREATE,
          flush: () => el.insertBefore(createElement(newVNodeChildren[deltaPosition], false), child)
        });
      }
      if (deltaType === DeltaTypes.UPDATE) {
        commit(() => {
          effects = diff(child, newVNodeChildren[deltaPosition], oldVNodeChildren[deltaPosition]);
        }, getData(child));
      }
      if (deltaType === DeltaTypes.REMOVE) {
        effects.push({
          el,
          type: EffectTypes.REMOVE,
          flush: () => el.removeChild(child)
        });
      }
    }
    return finish(el);
  }
  if (!newVNodeChildren || newVNode.flag === Flags.ELEMENT_NO_CHILDREN) {
    if (!oldVNodeChildren)
      return finish(el);
    effects.push({
      el,
      type: EffectTypes.REMOVE,
      flush: () => el.textContent = ""
    });
    return finish(el);
  }
  if (!oldVNodeChildren || oldVNodeChildren?.length === 0) {
    for (let i = 0; i < newVNodeChildren.length; ++i) {
      effects.push({
        el,
        type: EffectTypes.CREATE,
        flush: () => el.appendChild(createElement(newVNodeChildren[i], false))
      });
    }
    return finish(el);
  }
  if (newVNode.flag === Flags.ELEMENT_KEYED_CHILDREN) {
    if (!el[NODE_OBJECT_POOL_FIELD])
      el[NODE_OBJECT_POOL_FIELD] = /* @__PURE__ */ new Map();
    let oldHead = 0;
    let newHead = 0;
    let oldTail = oldVNodeChildren.length - 1;
    let newTail = newVNodeChildren.length - 1;
    while (oldHead <= oldTail && newHead <= newTail) {
      const oldTailVNode = oldVNodeChildren[oldTail];
      const newTailVNode = newVNodeChildren[newTail];
      const oldHeadVNode = oldVNodeChildren[oldHead];
      const newHeadVNode = newVNodeChildren[newHead];
      if (oldTailVNode.key === newTailVNode.key) {
        oldTail--;
        newTail--;
      } else if (oldHeadVNode.key === newHeadVNode.key) {
        oldHead++;
        newHead++;
      } else if (oldHeadVNode.key === newTailVNode.key) {
        const node = el.childNodes.item(oldHead++);
        const tail = newTail--;
        effects.push({
          el,
          type: EffectTypes.CREATE,
          flush: () => el.insertBefore(node, el.childNodes.item(tail).nextSibling)
        });
      } else if (oldTailVNode.key === newHeadVNode.key) {
        const node = el.childNodes.item(oldTail--);
        const head = newHead++;
        effects.push({
          el,
          type: EffectTypes.CREATE,
          flush: () => el.insertBefore(node, el.childNodes.item(head))
        });
      } else
        break;
    }
    if (oldHead > oldTail) {
      while (newHead <= newTail) {
        const head = newHead++;
        effects.push({
          el,
          type: EffectTypes.CREATE,
          flush: () => el.insertBefore(el[NODE_OBJECT_POOL_FIELD].get(newVNodeChildren[head].key) ?? createElement(newVNodeChildren[head], false), el.childNodes.item(head))
        });
      }
    } else if (newHead > newTail) {
      while (oldHead <= oldTail) {
        const head = oldHead++;
        const node = el.childNodes.item(head);
        el[NODE_OBJECT_POOL_FIELD].set(oldVNodeChildren[head].key, node);
        effects.push({
          el,
          type: EffectTypes.REMOVE,
          flush: () => el.removeChild(node)
        });
      }
    } else {
      const oldKeyMap = /* @__PURE__ */ new Map();
      for (; oldHead <= oldTail; ) {
        oldKeyMap.set(oldVNodeChildren[oldHead].key, oldHead++);
      }
      while (newHead <= newTail) {
        const head = newHead++;
        const newVNodeChild = newVNodeChildren[head];
        const oldVNodePosition = oldKeyMap.get(newVNodeChild.key);
        if (oldVNodePosition !== void 0) {
          const node = el.childNodes.item(oldVNodePosition);
          effects.push({
            el,
            type: EffectTypes.CREATE,
            flush: () => el.insertBefore(node, el.childNodes.item(head))
          });
          oldKeyMap.delete(newVNodeChild.key);
        } else {
          effects.push({
            el,
            type: EffectTypes.CREATE,
            flush: () => el.insertBefore(el[NODE_OBJECT_POOL_FIELD].get(newVNodeChild.key) ?? createElement(newVNodeChild, false), el.childNodes.item(head))
          });
        }
      }
      for (const [oldVNodeKey, oldVNodeValue] of oldKeyMap) {
        const node = el.childNodes.item(oldVNodeValue);
        el[NODE_OBJECT_POOL_FIELD].set(oldVNodeKey, node);
        effects.push({
          el,
          type: EffectTypes.REMOVE,
          flush: () => el.removeChild(node)
        });
      }
    }
    return finish(el);
  }
  if (newVNode.flag === Flags.ELEMENT_TEXT_CHILDREN) {
    const oldString = Array.isArray(oldVNode?.children) ? oldVNode?.children.join("") : oldVNode?.children;
    const newString = Array.isArray(newVNode?.children) ? newVNode?.children.join("") : newVNode?.children;
    if (oldString !== newString) {
      effects.push({
        el,
        type: EffectTypes.REPLACE,
        flush: () => el.textContent = newString
      });
    }
    return finish(el);
  }
  if (newVNode.flag === void 0 || newVNode.flag === Flags.ELEMENT) {
    if (oldVNodeChildren && newVNodeChildren) {
      const commonLength = Math.min(oldVNodeChildren.length, newVNodeChildren.length);
      for (let i = commonLength - 1; i >= 0; --i) {
        commit(() => {
          effects = diff(el.childNodes.item(i), newVNodeChildren[i], oldVNodeChildren[i]);
        }, getData(el));
      }
      if (newVNodeChildren.length > oldVNodeChildren.length) {
        for (let i = commonLength; i < newVNodeChildren.length; ++i) {
          const node = createElement(newVNodeChildren[i], false);
          effects.push({ el, type: EffectTypes.CREATE, flush: () => el.appendChild(node) });
        }
      } else if (newVNodeChildren.length < oldVNodeChildren.length) {
        for (let i = oldVNodeChildren.length - 1; i >= commonLength; --i) {
          effects.push({
            el,
            type: EffectTypes.REMOVE,
            flush: () => el.removeChild(el.childNodes.item(i))
          });
        }
      }
    } else if (newVNodeChildren) {
      for (let i = 0; i < newVNodeChildren.length; ++i) {
        const node = createElement(newVNodeChildren[i], false);
        effects.push({
          el,
          type: EffectTypes.CREATE,
          flush: () => el.appendChild(node)
        });
      }
    }
    return finish(el);
  }
  return finish(el);
};

const useNode = (drivers) => {
  const nodeDriver = (el, newVNode, oldVNode, commit = (work) => work(), effects = []) => {
    const resolvedOldVNode = resolveVNode(oldVNode) ?? el[OLD_VNODE_FIELD] ?? fromDomNodeToVNode(el);
    const resolvedNewVNode = resolveVNode(newVNode);
    const finish = (element) => {
      return {
        el: element,
        newVNode: resolvedNewVNode,
        oldVNode: resolvedOldVNode,
        effects
      };
    };
    if (resolvedNewVNode === void 0 || resolvedNewVNode === null) {
      effects.push({
        el,
        type: EffectTypes.REMOVE,
        flush: () => el.remove()
      });
      return finish(el);
    } else {
      const hasString = typeof resolvedOldVNode === "string" || typeof resolvedNewVNode === "string";
      if (hasString && resolvedOldVNode !== resolvedNewVNode) {
        const newEl = createElement(resolvedNewVNode, false);
        effects.push({
          el,
          type: EffectTypes.REPLACE,
          flush: () => el.replaceWith(newEl)
        });
        return finish(newEl);
      }
      if (!hasString && typeof resolvedOldVNode === "object" && typeof resolvedNewVNode === "object") {
        if (resolvedNewVNode.flag === Flags.ELEMENT_IGNORE || resolvedOldVNode.flag === Flags.ELEMENT_IGNORE) {
          return finish(el);
        }
        if (resolvedNewVNode.flag === Flags.ELEMENT_FORCE_UPDATE || resolvedOldVNode.flag === Flags.ELEMENT_FORCE_UPDATE) {
          const newEl = createElement(newVNode);
          el.replaceWith(newEl);
          return finish(el);
        }
        if (resolvedOldVNode.key === void 0 && resolvedNewVNode.key === void 0 || resolvedOldVNode.key !== resolvedNewVNode?.key) {
          if (resolvedOldVNode.tag !== resolvedNewVNode.tag) {
            const newEl = createElement(resolvedNewVNode, false);
            effects.push({
              el,
              type: EffectTypes.REPLACE,
              flush: () => el.replaceWith(newEl)
            });
            return finish(newEl);
          }
          if (resolvedNewVNode.flag !== Flags.ELEMENT_SKIP_DRIVERS) {
            for (let i = 0; i < drivers.length; ++i) {
              commit(() => {
                drivers[i](el, resolvedNewVNode, resolvedOldVNode, commit, effects, nodeDriver);
              }, {
                el,
                newVNode: resolvedNewVNode,
                oldVNode: resolvedOldVNode,
                effects
              });
            }
          }
        }
      }
      return finish(el);
    }
  };
  return nodeDriver;
};

const updateProp = (el, propName, oldPropValue, newPropValue, effects) => {
  if (oldPropValue === newPropValue)
    return;
  if (propName.startsWith("on")) {
    const eventPropName = propName.slice(2).toLowerCase();
    effects.push({
      el,
      type: EffectTypes.SET_PROP,
      flush: () => {
        el.removeEventListener(eventPropName, oldPropValue);
        el.addEventListener(eventPropName, newPropValue);
      }
    });
  } else if (propName.charCodeAt(0) === X_CHAR) {
    if (propName.charCodeAt(3) === COLON_CHAR) {
      el.setAttributeNS(XML_NS, propName, String(newPropValue));
    } else if (propName.charCodeAt(5) === COLON_CHAR) {
      el.setAttributeNS(XLINK_NS, propName, String(newPropValue));
    }
  } else if (el[propName] !== void 0 && !(el instanceof SVGElement)) {
    if (newPropValue) {
      effects.push({
        el,
        type: EffectTypes.SET_PROP,
        flush: () => el[propName] = newPropValue
      });
    } else {
      effects.push({
        el,
        type: EffectTypes.REMOVE_PROP,
        flush: () => {
          el[propName] = "";
          el.removeAttribute(propName);
          delete el[propName];
        }
      });
    }
  } else if (!newPropValue) {
    effects.push({
      el,
      type: EffectTypes.REMOVE_PROP,
      flush: () => el.removeAttribute(propName)
    });
  } else {
    effects.push({
      el,
      type: EffectTypes.SET_PROP,
      flush: () => el.setAttribute(propName, String(newPropValue))
    });
  }
};
const useProps = (drivers = []) => (el, newVNode, oldVNode, commit = (work) => work(), effects = []) => {
  const oldProps = oldVNode?.props;
  const newProps = newVNode?.props;
  const data = {
    el,
    newVNode,
    oldVNode,
    effects
  };
  if (oldProps !== newProps) {
    if (oldProps === void 0 || newProps === null) {
      for (const propName in newProps) {
        updateProp(el, propName, void 0, newProps[propName], effects);
      }
    } else if (newProps === void 0 || newProps === null) {
      for (const propName in oldProps) {
        updateProp(el, propName, oldProps[propName], void 0, effects);
      }
    } else {
      let matches = 0;
      for (const propName in oldProps) {
        updateProp(el, propName, oldProps[propName], Reflect.has(newProps, propName) ? (matches++, newProps[propName]) : void 0, effects);
      }
      const keys = Object.keys(newProps);
      for (let i = 0; matches < keys.length && i < keys.length; ++i) {
        const propName = keys[i];
        if (!Reflect.has(oldProps, propName)) {
          updateProp(el, propName, void 0, newProps[propName], effects);
          ++matches;
        }
      }
    }
  }
  for (let i = 0; i < drivers.length; ++i) {
    commit(() => {
      drivers[i](el, newVNode, oldVNode, commit, effects);
    }, data);
  }
  return data;
};

const workQueue = [];
let pending = false;
const isPending = () => pending;
const startTransition = (work) => {
  workQueue.push(work);
  if (!pending)
    requestIdleCallback(flushQueue);
};
const flushQueue = (deadline = {
  didTimeout: false,
  timeRemaining: () => Number.MAX_VALUE
}) => {
  pending = true;
  while (!navigator?.scheduling?.isInputPending({ includeContinuous: true }) && deadline.timeRemaining() > 0 && workQueue.length > 0) {
    const work = workQueue.shift();
    if (work)
      work();
  }
  if (workQueue.length > 0)
    requestIdleCallback(flushQueue);
  else
    pending = false;
};

const diff = useNode([useChildren(), useProps()]);
const patch = (el, newVNode, oldVNode, hook = () => true, effects = []) => {
  const commit = (work, data2) => {
    if (hook(data2.el, data2.newVNode, data2.oldVNode))
      work();
  };
  const data = diff(el, newVNode, oldVNode, commit, effects);
  effects.push({
    el: data.el,
    type: EffectTypes.SET_PROP,
    flush: () => data.el[OLD_VNODE_FIELD] = resolveVNode(newVNode)
  });
  for (let i = 0; i < effects.length; i++) {
    requestAnimationFrame(effects[i].flush);
  }
  return data.el;
};
const render = (parentEl, newVNode, oldVNode, hook) => {
  const el = parentEl[DOM_REF_FIELD];
  if (el) {
    return patch(el, newVNode, oldVNode, hook);
  } else {
    const newEl = createElement(newVNode);
    parentEl.textContent = "";
    parentEl.appendChild(newEl);
    parentEl[DOM_REF_FIELD] = newEl;
    return newEl;
  }
};
const hydrate = (el, vnode, intersect = true) => {
  const update = () => patch(el, vnode);
  if (intersect) {
    const io = new IntersectionObserver((entries) => {
      for (let i = 0; i < entries.length; i++) {
        if (entries[i].isIntersecting) {
          startTransition(update);
          io.disconnect();
          break;
        }
      }
    });
    io.observe(el);
  } else {
    startTransition(update);
  }
};

export { useNode as a, updateProp as b, createElement as c, useProps as d, diff as e, flushQueue as f, hydrate as h, isPending as i, patch as p, render as r, startTransition as s, useChildren as u };
