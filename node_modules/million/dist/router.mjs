import { p as patch, c as createElement } from './chunks/render.mjs';
import { m as morph } from './chunks/morph.mjs';
import './chunks/h.mjs';
import './chunks/convert.mjs';

const ANIMATION_DURATION = 300;
let interval;
const createProgressBar = () => {
  const style = document.createElement("style");
  style.type = "text/css";
  style.textContent = `.million-progress-bar {
    position: fixed;
    display: block;
    top: 0;
    left: 0;
    height: 2px;
    background: #0076ff;
    z-index: 2147483647;
    transition:
      width ${ANIMATION_DURATION}ms ease-out,
      opacity ${ANIMATION_DURATION / 2}ms ${ANIMATION_DURATION / 2}ms ease-in;
    transform: translate3d(0, 0, 0);
  }`;
  document.head.insertBefore(style, document.head.firstChild);
  const el = document.createElement("div");
  el.className = "million-progress-bar";
  return el;
};
const startTrickle = (el) => {
  let value = 0;
  el.style.width = "0";
  el.style.opacity = "1";
  document.documentElement.insertBefore(el, document.body);
  interval = window.setInterval(() => {
    value += Math.random() / 100;
    requestAnimationFrame(() => {
      el.style.width = `${10 + value * 90}%`;
    });
  }, ANIMATION_DURATION);
};
const stopTrickle = (el) => {
  clearInterval(interval);
  interval = void 0;
  el.style.width = "100%";
  el.style.opacity = "0";
  setTimeout(() => {
    if (document.documentElement.contains(el)) {
      document.documentElement.removeChild(el);
    }
  }, ANIMATION_DURATION * 1.5);
};

const setAttribute = (el, attr, base) => {
  el.setAttribute(attr, new URL(el.getAttribute(attr), base).pathname);
};
const normalizeRelativeURLs = (el, base) => {
  const hrefs = el.querySelectorAll('[href^="./"], [href^="../"]');
  const srcs = el.querySelectorAll('[src^="./"], [src^="../"]');
  for (let i = 0; i < hrefs.length; i++) {
    setAttribute(hrefs[i], "href", base);
  }
  for (let i = 0; i < srcs.length; i++) {
    setAttribute(srcs[i], "src", base);
  }
};
const isLocalURL = (href) => {
  try {
    const url = new URL(href);
    if (window.location.origin === url.origin) {
      if (url.pathname === window.location.pathname) {
        return !url.hash;
      }
      return true;
    }
  } catch (err) {
  }
  return false;
};
const getURL = ({ target }) => {
  const a = target.closest("a");
  if (!a || !isLocalURL(a.href))
    return void 0;
  else
    return new URL(a.href);
};

const parser = new DOMParser();
const routeMap = /* @__PURE__ */ new Map();
const progressBar = createProgressBar();
let lastUrl;
const setRoute = (path, route) => {
  routeMap.set(path, { ...routeMap.get(path), ...route });
};
const createRoute = (vnode, hook = () => true) => ({
  vnode,
  hook
});
const getEl = (el, selector) => {
  return selector ? el.querySelector(selector) : el;
};
const parseContent = (content, url) => {
  const html = parser.parseFromString(content, "text/html");
  normalizeRelativeURLs(html, url);
  return html;
};
const getContent = async (url, options) => {
  return fetch(String(url), options).then((res) => res.text()).catch(() => {
    window.location.assign(url);
  });
};
const navigate = async (url, selector, opts, goBack = false, scroll = 0) => {
  lastUrl = url;
  startTrickle(progressBar);
  const currentEl = getEl(document.documentElement, selector);
  if (!goBack) {
    history.pushState({ scroll: document.documentElement.scrollTop }, "", url);
  }
  window.scrollTo({ top: scroll, behavior: "auto" });
  if (routeMap.has(url.pathname)) {
    const route = routeMap.get(url.pathname);
    if (route.vnode) {
      try {
        patch(currentEl, route.vnode);
      } catch (_err) {
        const el = route.html ? getEl(route.html.documentElement, selector) : createElement(route.vnode);
        currentEl.replaceWith(el);
      }
    } else if (route.html) {
      const newEl = getEl(route.html.documentElement, selector);
      if (selector)
        document.title = route.html.title;
      try {
        morph(newEl, currentEl);
      } catch (_err) {
        currentEl.replaceWith(newEl);
      }
    }
  } else {
    const content = await getContent(url, opts);
    if (!content)
      return;
    const html = parseContent(content, url);
    setRoute(url.pathname, { html });
    if (selector)
      document.title = html.title;
    const newEl = getEl(html.documentElement, selector);
    try {
      morph(newEl, currentEl);
    } catch (_err) {
      currentEl.replaceWith(newEl);
    }
  }
  const navigateEvent = new CustomEvent("million:navigate", { detail: { url } });
  window.dispatchEvent(navigateEvent);
  stopTrickle(progressBar);
};
const router = (selector, routes = {}) => {
  for (const path in routes) {
    setRoute(path, routes[path]);
  }
  window.addEventListener("click", (event) => {
    const url = getURL(event);
    if (!url)
      return;
    const route = routeMap.get(url.pathname);
    if (route && route.hook && !route.hook(url, route))
      return;
    event.preventDefault();
    try {
      navigate(url, selector);
    } catch (_err) {
      window.location.assign(url);
    }
  });
  window.addEventListener("mouseover", async (event) => {
    const url = getURL(event);
    if (!url)
      return;
    const route = routeMap.get(url.pathname);
    if (route && route.hook && !route.hook(url, route))
      return;
    event.preventDefault();
    if (routeMap.has(url.pathname))
      return;
    const content = await getContent(url);
    if (content) {
      const html = parseContent(content, url);
      setRoute(url.pathname, { html });
    }
  });
  window.addEventListener("submit", async (event) => {
    const el = event.target;
    const url = new URL(el.action);
    if (!el.action || !(el instanceof HTMLFormElement))
      return;
    const route = routeMap.get(el.action);
    if (route && route.hook && !route.hook(url, route))
      return;
    event.stopPropagation();
    event.preventDefault();
    const formData = new FormData(el);
    const body = {};
    formData.forEach((value, key) => {
      body[key] = value;
    });
    navigate(url, selector, {
      method: el.method,
      redirect: "follow",
      body: !el.method || el.method.toLowerCase() === "get" ? `?${new URLSearchParams(body)}` : JSON.stringify(body)
    });
  });
  window.addEventListener("popstate", (event) => {
    const url = new URL(window.location.toString());
    if (url.hash && url.pathname === lastUrl?.pathname) {
      lastUrl = url;
      return;
    }
    const route = routeMap.get(url.pathname);
    if (route && route.hook && !route.hook(url, route))
      return;
    try {
      navigate(url, selector, {}, true, event.state?.scroll);
    } catch (_err) {
      window.location.reload();
    }
    return;
  });
  return routeMap;
};

export { createRoute, getContent, getEl, getURL, isLocalURL, navigate, normalizeRelativeURLs, parseContent, router, setAttribute, setRoute };
