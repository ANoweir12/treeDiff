// src/index.ts
import { parse as parse2 } from "tinyargs";

// src/build.ts
import { resolve as resolve2 } from "path";

// src/tree.ts
import { stat, readdir, readFile } from "fs/promises";
import { resolve } from "path";
var createTree = async (dir, name = "") => {
  const files = await readdir(dir);
  const children = await Promise.all(files.map(async (file) => {
    const path = resolve(dir, file);
    const stats = await stat(path);
    if (stats.isDirectory()) {
      return createTree(path, file);
    } else {
      const content = await readFile(resolve(dir, file), "utf8");
      return {
        type: 0 /* FILE */,
        name: file,
        path,
        content
      };
    }
  }));
  return {
    type: 1 /* FOLDER */,
    name,
    path: dir,
    children
  };
};

// src/build.ts
import { writeFile, mkdir } from "fs/promises";

// src/transform.ts
import matter from "gray-matter";
import { escape, unescape } from "html-escaper";
import { parse } from "marked";
import { getHighlighter } from "shiki";
var transform = async (markdown) => {
  const highlighter = await getHighlighter({ theme: "vitesse-light" });
  const { content, data } = matter(markdown);
  let body = parse(content);
  const codeBlocks = [
    ...body.matchAll(/<pre>\s*<code class="language-\w+">\s*(.*)\s*<\/code>\s*<\/pre>/gims)
  ];
  for (let i = 0; i < codeBlocks.length; i++) {
    const [original, replacement] = codeBlocks[i];
    const lang = [...original.matchAll(/language-(\w+)/gim)][0][1];
    body = body.replace(original, highlighter.codeToHtml(unescape(replacement), { lang }));
  }
  const head = `
    ${data && data.title ? `<title>${escape(data.title)}</title>` : ""}
    ${data && data.description ? `<meta name="description" content="${escape(data.description)}">` : ""}
    <meta charset="utf-8" />
    <link href="https://unpkg.com/latex.css" rel="stylesheet" />
    <script>
      import { router } from 'https://unpkg.com/million/dist/router.mjs';
      router('body');
    <\/script>
  `;
  const html = `<!DOCTYPE html><html lang="en"><head>${head}</head><body>${body}</body></html>`;
  return html;
};

// src/build.ts
var mkdirp = async (dir) => {
  try {
    mkdir(dir, { recursive: true });
  } catch (_err) {
  }
};
var build = async (inputDir, outDir) => {
  const tree = await createTree(inputDir);
  await writeNode(tree, outDir);
};
var writeNode = async (node, outDir) => {
  if (node.type === 1 /* FOLDER */) {
    await mkdirp(resolve2(outDir, node.name));
    for (const child of node.children) {
      await writeNode(child, resolve2(outDir, node.name));
    }
  }
  if (node.type === 0 /* FILE */) {
    await writeFile(resolve2(outDir, node.name.replace(/\.md$/, ".html")), await transform(node.content));
  }
};

// src/index.ts
import { resolve as resolve3 } from "path";
import { cwd } from "process";
import live from "live-server";
import chokidar from "chokidar";
var { command } = parse2(process.argv.slice(2), [
  { name: "command", type: String, positional: true }
]);
var gen = () => build(resolve3(cwd(), "pages"), resolve3(cwd(), "dist"));
gen();
if (command === "dev") {
  live.start({ root: resolve3(cwd(), "dist") });
  chokidar.watch("./pages").on("all", gen);
}
