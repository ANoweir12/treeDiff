var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

// src/index.ts
var import_tinyargs = require("tinyargs");

// src/build.ts
var import_path2 = require("path");

// src/tree.ts
var import_promises = require("fs/promises");
var import_path = require("path");
var createTree = async (dir, name = "") => {
  const files = await (0, import_promises.readdir)(dir);
  const children = await Promise.all(files.map(async (file) => {
    const path = (0, import_path.resolve)(dir, file);
    const stats = await (0, import_promises.stat)(path);
    if (stats.isDirectory()) {
      return createTree(path, file);
    } else {
      const content = await (0, import_promises.readFile)((0, import_path.resolve)(dir, file), "utf8");
      return {
        type: 0 /* FILE */,
        name: file,
        path,
        content
      };
    }
  }));
  return {
    type: 1 /* FOLDER */,
    name,
    path: dir,
    children
  };
};

// src/build.ts
var import_promises2 = require("fs/promises");

// src/transform.ts
var import_gray_matter = __toESM(require("gray-matter"), 1);
var import_html_escaper = require("html-escaper");
var import_marked = require("marked");
var import_shiki = require("shiki");
var transform = async (markdown) => {
  const highlighter = await (0, import_shiki.getHighlighter)({ theme: "vitesse-light" });
  const { content, data } = (0, import_gray_matter.default)(markdown);
  let body = (0, import_marked.parse)(content);
  const codeBlocks = [
    ...body.matchAll(/<pre>\s*<code class="language-\w+">\s*(.*)\s*<\/code>\s*<\/pre>/gims)
  ];
  for (let i = 0; i < codeBlocks.length; i++) {
    const [original, replacement] = codeBlocks[i];
    const lang = [...original.matchAll(/language-(\w+)/gim)][0][1];
    body = body.replace(original, highlighter.codeToHtml((0, import_html_escaper.unescape)(replacement), { lang }));
  }
  const head = `
    ${data && data.title ? `<title>${(0, import_html_escaper.escape)(data.title)}</title>` : ""}
    ${data && data.description ? `<meta name="description" content="${(0, import_html_escaper.escape)(data.description)}">` : ""}
    <meta charset="utf-8" />
    <link href="https://unpkg.com/latex.css" rel="stylesheet" />
    <script>
      import { router } from 'https://unpkg.com/million/dist/router.mjs';
      router('body');
    <\/script>
  `;
  const html = `<!DOCTYPE html><html lang="en"><head>${head}</head><body>${body}</body></html>`;
  return html;
};

// src/build.ts
var mkdirp = async (dir) => {
  try {
    (0, import_promises2.mkdir)(dir, { recursive: true });
  } catch (_err) {
  }
};
var build = async (inputDir, outDir) => {
  const tree = await createTree(inputDir);
  await writeNode(tree, outDir);
};
var writeNode = async (node, outDir) => {
  if (node.type === 1 /* FOLDER */) {
    await mkdirp((0, import_path2.resolve)(outDir, node.name));
    for (const child of node.children) {
      await writeNode(child, (0, import_path2.resolve)(outDir, node.name));
    }
  }
  if (node.type === 0 /* FILE */) {
    await (0, import_promises2.writeFile)((0, import_path2.resolve)(outDir, node.name.replace(/\.md$/, ".html")), await transform(node.content));
  }
};

// src/index.ts
var import_path3 = require("path");
var import_process = require("process");
var import_live_server = __toESM(require("live-server"), 1);
var import_chokidar = __toESM(require("chokidar"), 1);
var { command } = (0, import_tinyargs.parse)(process.argv.slice(2), [
  { name: "command", type: String, positional: true }
]);
var gen = () => build((0, import_path3.resolve)((0, import_process.cwd)(), "pages"), (0, import_path3.resolve)((0, import_process.cwd)(), "dist"));
gen();
if (command === "dev") {
  import_live_server.default.start({ root: (0, import_path3.resolve)((0, import_process.cwd)(), "dist") });
  import_chokidar.default.watch("./pages").on("all", gen);
}
